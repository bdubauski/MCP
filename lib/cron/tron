#!/usr/bin/env python3
#
#  tron
#    retreive packages from packrat and track their status and handle promoting
#
#
import os

os.environ.setdefault( 'DJANGO_SETTINGS_MODULE', 'mcp.settings' )

import django
django.setup()

import logging
import sys
from logging.handlers import SysLogHandler

from mcp.Project.models import Package, PackageVersion, BuildDependancy
from mcp.Processor.models import Promotion, QueueItem, PromotionBuild, PromotionPkgVersion
from mcp.lib.Packrat import getPackrat
from mcp.lib.Slack import getSlack

PID_FILE = '/var/run/tron.pid'

QUEUE_PRIORITY = 100

logging.basicConfig()
logger = logging.getLogger()
handler = SysLogHandler( address='/dev/log', facility=SysLogHandler.LOG_DAEMON )
handler.setFormatter( logging.Formatter( fmt='recognizer[%(process)d]: %(message)s' ) )
logger.addHandler( handler )
logging.info( 'Starting...' )
if '-v' in sys.argv:
  logger.setLevel( logging.DEBUG )
elif '-c' in sys.argv:
  logger.setLevel( logging.ERROR )
else:
  logger.setLevel( logging.INFO )

if os.path.exists( PID_FILE ):
  logging.error( 'pid file exists, bailing...' )
  sys.exit( 0 )

tmp = open( PID_FILE, 'w' )
tmp.write( '{0}\n'.format( os.getpid() ) )
tmp.close()

slack = getSlack( 'tron' )
packrat = getPackrat()

tag_requirements_map = dict( [ ( k, set( v ) ) for ( k, v ) in packrat.tag_requirements_map().items() ] )
available_tag_set = set( tag_requirements_map.keys() )
tag_name_map = dict( [ ( i, i.split( ':' )[1] ) for i in available_tag_set ] )


def _queuePromotion( pkg_version, packrat_id, tag ):
  package = pkg_version.package

  dependancy_list = BuildDependancy.objects.filter( package=package, tag=tag )
  if len( dependancy_list ) == 0:
    logging.info( 'No Dependancies for package "{0}" version "{1}" for tag "{2}", tagging...'.format( package.name, pkg_version.version, tag ) )
    packrat.tag( packrat_id, tag )
    slack.post_message( 'No Dependancies for package "{0}" version "{1}" for tag "{2}", tagged'.format( package.name, pkg_version.version, tag ), slack.SUCCESS )
    return

  logging.info( 'Creating Promotion for package "{0}" version "{1}" for tag "{2}"...'.format( package.name, pkg_version.version, tag ) )
  promotion = Promotion()
  promotion.tag = tag
  promotion.full_clean()
  promotion.save()

  promotion_pkg_version = PromotionPkgVersion()
  promotion_pkg_version.promotion = promotion
  promotion_pkg_version.package_version = pkg_version
  promotion_pkg_version.packrat_id = packrat_id
  promotion_pkg_version.full_clean()
  promotion_pkg_version.save()

  for dependancy in dependancy_list:
    promition_build = PromotionBuild()
    promition_build.promotion = promotion
    promition_build.build = dependancy.build
    promition_build.status = 'queued'
    promition_build.full_clean()
    promition_build.save()
    promotion.queueitem_set.add( QueueItem.inQueueBuild( dependancy.build, 'master', False, QUEUE_PRIORITY, '*AUTO*', promotion=promotion ) )


# look for promotion that is done
for promotion in Promotion.objects.all():
  logging.debug( 'Checking promtion "{0}"'.format( promotion ) )
  done = True
  success = True
  for promotion_build in promotion.promotionbuild_set.all():
    done &= ( promotion_build.status == 'done' )
    success &= bool( promotion_build.success )

  if not done:
    continue

  if success:
    for promotion_pkg_version in promotion.promotionpkgversion_set.all():
      logging.info( 'Tagging "{0}" version "{1}" with "{2}".'.format( promotion_pkg_version.package_version.package.name, promotion_pkg_version.package_version.version, promotion.tag ) )
      packrat.tag( promotion_pkg_version.packrat_id, promotion.tag )
      slack.post_message( 'Tagged "{0}" version "{1}" with "{2}".'.format( promotion_pkg_version.package_version.package.name, promotion_pkg_version.package_version.version, promotion.tag ), slack.SUCCESS )

  else:
    for promotion_pkg_version in promotion.promotionpkgversion_set.all():
      logging.info( 'Failing "{0}" version "{1}".'.format( promotion_pkg_version.package_version.package.name, promotion_pkg_version.package_version.version ) )
      packrat.fail( promotion_pkg_version.packrat_id )
      slack.post_message( 'Failed "{0}" version "{1}".'.format( promotion_pkg_version.package_version.package.name, promotion_pkg_version.package_version.version ), slack.ERROR )

  promotion.delete()


# iterate over packagefile .groupby 'group'
# pull all the object in the group, make sure they are at the same level
# if they are no longer in packrat, delete the PackageFile object
# scan to see if there are tags to do, if so create promotion

# look for new package versions
for name in packrat.packages():
  logging.info( 'Checking package "{0}"...'.format( name ) )
  try:
    package = Package.objects.get( pk=name )
  except Package.DoesNotExist:
    package = Package()
    package.name = name
    package.full_clean()
    package.save()

  for ( package_file_uri, package_file ) in packrat.package_files( package.name ):
    if package_file[ 'deprocated_at' ] or package_file[ 'failed_at' ]:
      continue

    package_file_tag_set = set( package_file[ 'raw_tag_list' ] )
    for tag in available_tag_set - package_file_tag_set:  # Iterate over all the tags not yet set
      if len( tag_requirements_map[ tag ] - package_file_tag_set ) != 0:  # Not all requiremenets are met
        continue

      try:
        pkg_version = PackageVersion.objects.get( package=package, version=package_file[ 'version' ] )

      except PackageVersion.DoesNotExist:
        pkg_version = PackageVersion()
        pkg_version.package = package
        pkg_version.version = package_file[ 'version' ]
        pkg_version.full_clean()
        pkg_version.save()

      if pkg_version.promotion_set.all().count() > 0:  # this package is being worked on
        continue

      _queuePromotion( pkg_version, package_file_uri, tag_name_map[ tag ] )

packrat.logout()

os.unlink( PID_FILE )
logging.info( 'Done!' )
logging.shutdown()
sys.exit( 0 )
