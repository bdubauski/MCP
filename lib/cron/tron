#!/usr/bin/env python3
#
#  tron
#    retreive packages from packrat and track their status and handle promoting
#
#
import os

os.environ.setdefault( 'DJANGO_SETTINGS_MODULE', 'mcp.settings' )

import django
django.setup()

import logging
import sys
import cinp
from logging.handlers import SysLogHandler
from datetime import datetime, timezone

from mcp.Project.models import Package, BuildDependancy
from mcp.Processor.models import Promotion, QueueItem, PromotionBuild, PackageFile
from mcp.lib.Packrat import getPackrat
from mcp.lib.Slack import getSlack

PID_FILE = '/var/run/tron.pid'

QUEUE_PRIORITY = 100

logging.basicConfig()
logger = logging.getLogger()
handler = SysLogHandler( address='/dev/log', facility=SysLogHandler.LOG_DAEMON )
handler.setFormatter( logging.Formatter( fmt='recognizer[%(process)d]: %(message)s' ) )
logger.addHandler( handler )
logging.info( 'Starting...' )
if '-v' in sys.argv:
  logger.setLevel( logging.DEBUG )
elif '-c' in sys.argv:
  logger.setLevel( logging.ERROR )
else:
  logger.setLevel( logging.INFO )

if os.path.exists( PID_FILE ):
  logging.error( 'pid file exists, bailing...' )
  sys.exit( 0 )

tmp = open( PID_FILE, 'w' )
tmp.write( '{0}\n'.format( os.getpid() ) )
tmp.close()

slack = getSlack( 'tron' )
packrat = getPackrat()

tag_requirements_map = dict( [ ( k, set( v ) ) for ( k, v ) in packrat.tag_requirements_map().items() ] )
available_tag_set = set( tag_requirements_map.keys() )
tag_name_map = dict( [ ( i, i.split( ':' )[1] ) for i in available_tag_set ] )


def _tagGroup( group, tag ):
  for package_file in PackageFile.objects.filter( group=group ):
    logging.info( 'Tagging package "{0}" with "{1}".'.format( package_file.filename, tag ) )
    packrat.tag( package_file.packrat_id, tag )
    slack.post_message( 'Tagged package "{0}" with "{1}".'.format( package_file.filename, tag ), slack.SUCCESS )


def _failGroup( group ):
  for package_file in PackageFile.objects.filter( group=group ):
    logging.info( 'Failing package "{0}".'.format( package_file.filename ) )
    packrat.fail( package_file.packrat_id )
    slack.post_message( 'Failed package "{0}".'.format( package_file.filename ), slack.ERROR )


def _queuePromotion( group, package_list, tag ):
  dependancy_list = BuildDependancy.objects.filter( package__in=package_list, tag=tag )

  logging.info( 'Tagging group "{0}" with "{1}"'.format( group, tag ) )
  _tagGroup( group, tag )
  slack.post_message( 'Group "{0}" tagged with "{1}" '.format( group, tag ), slack.SUCCESS )

  if len( dependancy_list ) == 0:
    logging.info( 'No Dependancies for group "{0}" for tag "{1}"'.format( group, tag ) )
    return

  logging.info( 'Creating Promotion check for group "{0}" for tag "{1}"...'.format( group, tag ) )
  promotion = Promotion()
  promotion.group = group
  promotion.tag = tag
  promotion.full_clean()
  promotion.save()

  for dependancy in dependancy_list:
    promition_build = PromotionBuild()
    promition_build.promotion = promotion
    promition_build.build = dependancy.build
    promition_build.status = 'queued'
    promition_build.full_clean()
    promition_build.save()
    promotion.queueitem_set.add( QueueItem.inQueueBuild( dependancy.build, 'master', False, QUEUE_PRIORITY, '*AUTO*', promotion=promotion ) )


# look for promotion that is done
for promotion in Promotion.objects.filter( done_at__isnull=True ):
  logging.debug( 'Checking promtion "{0}"'.format( promotion ) )
  done = True
  success = True
  for promotion_build in promotion.promotionbuild_set.all():
    done &= ( promotion_build.status == 'done' )
    success &= bool( promotion_build.success )

  if not done:
    continue

  if success:
    logging.info( 'Group "{0}" for tag "{1}" passed.'.format( promotion.group, promotion.tag ) )
    slack.post_message( 'Group "{0}" for tag "{1}" passed.'.format( promotion.group, promotion.tag ), slack.SUCCESS )

  else:
    logging.info( 'Failing group "{0}".'.format( promotion.group ) )
    _failGroup( promotion.group )
    slack.post_message( 'Failed group "{0}".'.format( promotion.group ), slack.ERROR )

  promotion.done_at = datetime.now( timezone.utc )
  promotion.full_clean()
  promotion.save()


# go over the package files and see if they still exist
for package_file in PackageFile.objects.all():
  # TODO: instead of getting them one at a time from packrat, get them in groups.
  # TODO: have some kind of detection to see if packrat is broken and 404ing everything,
  #       mabey when doing groups, ask for groups of 50, and if it comes back empty, bail.
  try:
    packrat.cinp.get( package_file.packrat_id )
  except cinp.client.NotFound:
    logging.info( 'Package File "{0}", is gone, deleting...'.format( package_file.filename ) )
    package_file.delete()


# look for promotion to cleanup
for promotion in Promotion.objects.filter( done_at__isnull=False ):
  if PackageFile.objects.filter( group=promotion.group ).count() == 0:
    promotion.delete()


# iterate over the groups of package files
for group in PackageFile.objects.all().values_list( 'group', flat=True ).distinct():
  if Promotion.objects.filter( group=group, done_at__isnull=True ).count() > 0:
    logging.info( 'Group "{0}" allready has promotion(s), skipping...'.format( group ) )
    continue

  id_list = list( PackageFile.objects.filter( group=group ).values_list( 'packrat_id', flat=True ) )
  # TODO: get the full id_list from packrat in one request instead of asking for them one at a time
  try:
    package_file = packrat.cinp.get( id_list.pop() )
  except cinp.client.NotFound:
    logging.info( 'Package disapeared, will try group "{0}" next time'.format( group ) )
    continue

  if package_file[ 'deprocated_at' ] or package_file[ 'failed_at' ]:
   logging.info( 'Group "{0}" is deprocated/faield, skipping...'.format( group ) )
   continue

  clean = True
  tag_list = package_file[ 'tags' ]
  while id_list and clean:
    try:
      package_file = packrat.cinp.get( id_list.pop() )
    except cinp.client.NotFound:
      logging.info( 'Package disapeared, will try group "{0}" next time'.format( group ) )
      clean = False
      continue

    if package_file[ 'tags' ] != tag_list:
      logging.warn( 'tag missmatch in group "{0}", skipping...'.format( group ) )
      clean = False
      continue

    if package_file[ 'deprocated_at' ] or package_file[ 'failed_at' ]:
     logging.info( 'deprocated/faield missmatch in group "{0}", skipping...'.format( group ) )
     clean = False
     continue

  if not clean:
    continue

  # ok, all of the group is consistant and accounted for, let's check the tags
  package_file_tag_set = set( package_file[ 'raw_tag_list' ] )
  for tag in available_tag_set - package_file_tag_set:  # Iterate over all the tags not yet set
    if len( tag_requirements_map[ tag ] - package_file_tag_set ) != 0:  # Not all requiremenets are met
      continue

    package_list = Package.objects.filter( packagefile__group=group )
    _queuePromotion( group, package_list, tag_name_map[ tag ] )

packrat.logout()

os.unlink( PID_FILE )
logging.info( 'Done!' )
logging.shutdown()
sys.exit( 0 )
