#!/usr/bin/env python3
#
#  tron
#    retreive packages from packrat and track their status and handle promoting
#
#
import os

os.environ.setdefault( 'DJANGO_SETTINGS_MODULE', 'mcp.settings' )

import django
django.setup()

import logging
import sys
from logging.handlers import SysLogHandler
from django.conf import settings

from mcp.Project.models import Package, PackageVersion, BuildDependancy
from mcp.Processor.models import Promotion, QueueItem, PromotionBuild, PromotionPkgVersion
from mcp.lib.Packrat import Packrat
from mcp.lib.Slack import Slack

PID_FILE = '/var/run/tron.pid'

QUEUE_PRIORITY = 100

logging.basicConfig()
logger = logging.getLogger()
handler = SysLogHandler( address='/dev/log', facility=SysLogHandler.LOG_DAEMON )
handler.setFormatter( logging.Formatter( fmt='recognizer[%(process)d]: %(message)s' ) )
logger.addHandler( handler )
logging.info( 'Starting...' )
if '-v' in sys.argv:
  logger.setLevel( logging.DEBUG )
elif '-c' in sys.argv:
  logger.setLevel( logging.ERROR )
else:
  logger.setLevel( logging.INFO )

if os.path.exists( PID_FILE ):
  logging.error( 'pid file exists, bailing...' )
  sys.exit( 0 )

tmp = open( PID_FILE, 'w' )
tmp.write( '{0}\n'.format( os.getpid() ) )
tmp.close()

logging.info( 'Connecting to Packrat...' )
packrat = Packrat( settings.PACKRAT_HOST, settings.PACKRAT_PROXY, settings.PACKRAT_USERNAME, settings.PACKRAT_PSK )

slack = Slack( 'tron', settings.SLACK_API_TOKEN, settings.SLACK_CHANNEL, settings.SITE_NAME, settings.SLACK_PROXY )

tag_requirements_map = dict( [ ( k, set( v ) ) for ( k, v ) in packrat.tag_requirements_map().items() ] )
available_tag_set = set( tag_requirements_map.keys() )
tag_name_map = dict( [ ( i, i.split( ':' )[1] ) for i in available_tag_set ] )


def _queuePromotion( pkg_version, packrat_id, tag ):
  package = pkg_version.package

  promotion = None
  try:  # TODO: the filter().distinct().get() buesines is due to a django bug that will return a Promotion for each package_version.... someday look into this
    promotion = Promotion.objects.filter( promotionpkgversion__package_version__package=package ).distinct().get()
  except Promotion.DoesNotExist:
    pass

  if promotion:
    if promotion.tag != tag:
      logging.warning( 'Package "{0}" version "{1}" has differing tag from existing promotion, going to ignore for now.'.format( package.name, pkg_version.version ) )
      return

    # TODO: really any package that has the same target build and state should join the club... assuming it get's on board before
    #       the repo snapshot is made for the build to operate from
    logging.info( 'Joining package "{0}" version "{1}" to Existing Promotion...'.format( package.name, pkg_version.version ) )
    promotion_pkg_version = PromotionPkgVersion()
    promotion_pkg_version.promotion = promotion
    promotion_pkg_version.package_version = pkg_version
    promotion_pkg_version.packrat_id = packrat_id
    promotion_pkg_version.full_clean()
    promotion_pkg_version.save()
    return

  dependancy_list = BuildDependancy.objects.filter( package=package, tag=tag )
  if len( dependancy_list ) == 0:
    logging.info( 'No Dependancies for package "{0}" version "{1}" for tag "{2}", tagging...'.format( package.name, pkg_version.version, tag ) )
    packrat.tag( packrat_id, tag )
    slack.post_message( 'No Dependancies for package "{0}" version "{1}" for tag "{2}", tagged'.format( package.name, pkg_version.version, tag ), slack.SUCCESS )
    return

  logging.info( 'Creating Promotion for package "{0}" version "{1}" for tag "{2}"...'.format( package.name, pkg_version.version, tag ) )
  promotion = Promotion()
  promotion.tag = tag
  promotion.full_clean()
  promotion.save()

  promotion_pkg_version = PromotionPkgVersion()
  promotion_pkg_version.promotion = promotion
  promotion_pkg_version.package_version = pkg_version
  promotion_pkg_version.packrat_id = packrat_id
  promotion_pkg_version.full_clean()
  promotion_pkg_version.save()

  for dependancy in dependancy_list:
    promition_build = PromotionBuild()
    promition_build.promotion = promotion
    promition_build.build = dependancy.build
    promition_build.status = 'queued'
    promition_build.full_clean()
    promition_build.save()
    promotion.queueitem_set.add( QueueItem.inQueueBuild( dependancy.build, 'master', False, QUEUE_PRIORITY, '*AUTO*', promotion=promotion ) )


# look for promotion that is done
for promotion in Promotion.objects.all():
  logging.debug( 'Checking promtion "{0}"'.format( promotion ) )
  done = True
  success = True
  for promotion_build in promotion.promotionbuild_set.all():
    done &= ( promotion_build.status == 'done' )
    success &= bool( promotion_build.success )

  if not done:
    continue

  if success:
    for promotion_pkg_version in promotion.promotionpkgversion_set.all():
      logging.info( 'Tagging "{0}" version "{1}" with "{2}".'.format( promotion_pkg_version.package_version.package.name, promotion_pkg_version.package_version.version, promotion.tag ) )
      packrat.tag( promotion_pkg_version.packrat_id, promotion.tag )
      slack.post_message( 'Tagged "{0}" version "{1}" with "{2}".'.format( promotion_pkg_version.package_version.package.name, promotion_pkg_version.package_version.version, promotion.tag ), slack.SUCCESS )

  else:
    for promotion_pkg_version in promotion.promotionpkgversion_set.all():
      logging.info( 'Failing "{0}" version "{1}".'.format( promotion_pkg_version.package_version.package.name, promotion_pkg_version.package_version.version ) )
      packrat.fail( promotion_pkg_version.packrat_id )
      slack.post_message( 'Failed "{0}" version "{1}".'.format( promotion_pkg_version.package_version.package.name, promotion_pkg_version.package_version.version ), slack.ERROR )

  promotion.delete()

# look for new package versions
for name in packrat.packages():
  logging.info( 'Checking package "{0}"...'.format( name ) )
  try:
    package = Package.objects.get( pk=name )
  except Package.DoesNotExist:
    package = Package()
    package.name = name
    package.full_clean()
    package.save()

  for ( package_file_uri, package_file ) in packrat.package_files( package.name ):
    package_file_tag_set = set( package_file[ 'raw_tag_list' ] )
    for tag in available_tag_set - package_file_tag_set:  # Iterate over all the tags not yet set
      if len( tag_requirements_map[ tag ] - package_file_tag_set ) != 0:  # Not all requiremenets are met
        continue

      try:
        pkg_version = PackageVersion.objects.get( package=package, version=package_file[ 'version' ] )

      except PackageVersion.DoesNotExist:
        pkg_version = PackageVersion()
        pkg_version.package = package
        pkg_version.version = package_file[ 'version' ]
        pkg_version.full_clean()
        pkg_version.save()

      if pkg_version.promotion_set.all().count() > 0:  # this package is being worked on
        continue

      _queuePromotion( pkg_version, package_file_uri, tag_name_map[ tag ] )

packrat.logout()

os.unlink( PID_FILE )
logging.info( 'Done!' )
logging.shutdown()
sys.exit( 0 )
